src/
 - ExecutionContext.java    // контекст исполнения
 - Command.java             // абстрактный класс команды
 - CommandFactory.java      // фабрика команд
 - commands/
|    -  PushCommand.java     // PUSH
|    -  PopCommand.java      // POP
|    -  AddCommand.java      // +
|    -  DefineCommand.java   // DEFINE
|    -  PrintCommand.java    // PRINT
 -  StackCalculator.java     // Основной класс
 -  commands.properties      // конфигурация фабрики

1 ExecutionContext.java (контекст исполнения - было в методических указаниях)
Хранение данных, необходимых для выполнения команд.
Хранит:
    Стек (Stack<Double>) для работы с числами
    Ассоциативный массив (Map<String, Double>) для хранения переменных и их значений соответственно
Методы:
    getStack(): возвращает ссылку на стек
    getVariables(): возвращает ссылку на переменные

2 Command.java (абстрактный класс)
Не может быть создан напрямую (нельзя создать объект этого класса).
Он используется как основа для других классов.

Обеспечивает единообразие реализации команд, также так проще расширять функционал методов.
Содержит:
    Один абстрактный метод Execute(ExecutionContext context, String[] args) (сам метод не имеет реализации т.к. abstract)
        принимает текущий контекст исполнения (ExecutionContext) - стек и переменные
        получает аргументы команды (args), если они есть
        реализуется в дочерних классах, определяя логику конкретной команды

3 CommandFactory.java
  Ответственность: создание объектов команд на основе их имени

  Что делает:
    Хранит сопоставление между именами команд и их классами (PUSH -> PushCommand)
    При необходимости создает объект команды с помощью рефлексии (Class.forName())
    Загрузка конфигурации (например, из файла commands.properties)

  Техническая составляющая:
    static {
        try (InputStream input = CommandFactory.class.getResourceAsStream("/commands.properties")) {
            Properties properties = new Properties();
            properties.load(input);
            for (String name : properties.stringPropertyNames()) {
                command_map.put(name, properties.getProperty(name));
            }
        } catch (IOException e) {
            throw new RuntimeException("Ошибка при загрузке конфигурации команд", e);
        }
    }

    3.1.1 CommandFactory.class.getResourceAsStream("/commands.properties") - Загружает файл commands.properties
    3.1.2 Properties - класс используется для работы с текстовыми файлами формата ключ=значение
    3.1.3 цикл for
        для каждого ключа из commands.properties ("PUSH") в карту command_map добавляется пара типа:
        PUSH -> task2.commands.PushCommand
    3.1.4 если например файл отсутствует или какая-то ошибка чтения то RuntimeException

    public static Command CreateCommand(String name) throws Exception {
        String class_name = command_map.get(name);
        if (class_name == null) {
            throw new IllegalArgumentException("Неизвестная команда: " + name);
        }
        return (Command) Class.forName(class_name).getDeclaredConstructor().newInstance();
    }

    3.2.1 Метод принимает строку - ключ name ("PUSH") и ищет соответствующее имя класса - значение в карте command_map.
          Если команда не найдена, выбрасывается исключение.
    3.2.2 Class.forName(className) - находит класс по его имени
    3.2.3 getDeclaredConstructor().newInstance() - вызывает конструктор класса (у нас без параметров)
            и создает новый экземпляр класса

4 Реализация конкретных комманд в директиве commands

5 Main.java
  Основная команда

  Что делает:
      считывает команды из файла ИЛИ стандартного ввода

      делит каждую строку на имя команды и аргументы
      использует CommandFactory для создания команды
      передает команду для выполнения в контексте (в ExecutionContext)

      обрабатывает исключения и пишет логи

  Про журналирование (логгинг):
    Журналирование в программировании позволяет записывать сообщения (логи) в процессе работы программы.

    private static final Logger logger = Logger.getLogger(Main.class.getName());
    создаёт объект логгера для записи сообщений. Логгер ассоциируется с текущим классом (Main),
        чтобы можно было понять, из какого места программы пришло сообщение.

